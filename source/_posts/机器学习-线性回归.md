---
title: '[æœºå™¨å­¦ä¹ ]çº¿æ€§å›å½’'
date: 2024-04-23 22:19:44
categories: æœºå™¨å­¦ä¹ 
tags: æœºå™¨å­¦ä¹ 
---

# 1.åŸç†

## 1.1 é—­å¼

æ¨¡å‹ï¼š${h_\theta }(x) = {\theta ^T}X$

æŸå¤±å‡½æ•°ï¼š$J(\theta ) = {\left\| {X\theta  - Y} \right\|_2}^2$

ç›®æ ‡ï¼š
$$
\begin{array}{l}
\min J(\theta )\\
\theta  = \arg \min J(\theta )
\end{array}
$$
è¯´æ˜: 
$$
\left\{ \begin{gathered}
  \theta  \in {\mathbb{R}^{d \times 1}} \hfill \\
  X \in {\mathbb{R}^{m \times d}} \hfill \\
  Y \in {\mathbb{R}^{m \times 1}} \hfill \\ 
\end{gathered}  \right.
$$
æ­£è§„æ–¹ç¨‹å½¢å¼æ±‚è§£ï¼Œå³ä¸ºç›´æ¥æ±‚$J(\theta)$çš„æœ€å°å€¼ï¼š
$$
\begin{align*}
J(\theta ) &= {\left\| {X\theta  - Y} \right\|_2}^2\\
&= {(X\theta  - Y)^T}(X\theta  - Y)\\
&= ({X^T}{\theta ^T} - {Y^T})(X\theta  - Y)\\
&= {X^T}{\theta ^T}X\theta  - {Y^T}X\theta  - {Y^T}X\theta  + {Y^T}Y\\
&= {X^T}{\theta ^T}X\theta  - 2{Y^T}X\theta  + {Y^T}Y
\end{align*}
$$
å¯¹$J(\theta)$è¿›è¡Œæ±‚å¯¼ï¼š
$$
\begin{align*}
\frac{{\partial J(\theta )}}{{\partial \theta }} &= \frac{{\partial {X^T}{\theta ^T}X\theta  - 2{Y^T}X\theta  + {Y^T}Y}}{{\partial \theta }} \\ 
&= 2{X^T}X\theta  - 2{Y^T}X \\ 
\end{align*}
$$
ä»¤$J(\theta)=0$å¾—ï¼š
$$
\begin{align*}
2{X^T}X\theta  - 2{Y^T}X &= 0 \\ 
{X^T}X\theta  &= {Y^T}X \\ 
\theta  &= {({X^T}X)^{ - 1}}{Y^T}X \\ 
\end{align*}
$$
ä¸Šè¿°ç»“æœå³ä¸ºæ±‚è§£ç»“æœï¼Œéœ€è¦è¯´æ˜çš„æ˜¯ï¼šç‰¹å¾çŸ©é˜µğ‘¿ä¸æ»¡ç§©ï¼ˆå³å­˜åœ¨ç‰¹å¾é—´çš„çº¿æ€§ç›¸å…³æ€§ï¼‰ï¼Œåˆ™æ­£è§„æ–¹ç¨‹æ±‚è§£è¿‡ç¨‹ä¸­çš„çŸ©é˜µæ±‚é€†æ“ä½œå¯èƒ½ä¼šå¯¼è‡´æ•°å€¼ä¸ç¨³å®šæ€§ã€‚

## 1.2 æ¢¯åº¦ä¸‹é™

æ¨¡å‹ï¼š$\[{h_\theta }(x) = \sum\limits_{i = 1}^d {{\theta _i}{x_i}} \]$

æŸå¤±å‡½æ•°ï¼š$J(\theta ) = \frac{1}{{2m}}{\sum\limits_{j = 0}^m {\left( {{y^j} - {h_\theta }({x^j})} \right)} ^2}$

ç›®æ ‡ï¼š
$$
\begin{array}{l}
\min J(\theta )\\
\theta  = \arg \min J(\theta )
\end{array}
$$
è¯´æ˜ï¼š
$$
\left\{ \begin{gathered}
  \theta  \in {\mathbb{R}^d} \hfill \\
  x \in {\mathbb{R}^d} \hfill \\
  y \in {\mathbb{R}^m} \hfill \\ 
\end{gathered}  \right.
$$


# 2.Pythonå®ç°

## 2.0 å¯¼åŒ…

```python
# å¯¼å…¥æ‰€éœ€çš„åŒ…
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import OneHotEncoder
from sklearn.model_selection import train_test_split
import time

%matplotlib inline
%config InlineBackend.figure_format = 'svg'
```

## 2.1 è¯»å–æ•°æ®é›†

```python
# è¯»å–æ•°æ®
df = pd.read_csv("./housing.csv")
# é¢„è§ˆæ•°æ®
print(df.head())

print(df.info())
```

## 2.2 æ•°æ®æ¢ç´¢

### 2.2.1 æ•°æ®åˆ†å¸ƒæƒ…å†µ

```python
i = 2
fig, ax = plt.subplots(3, 3, figsize=(18, 18))

# æ•£ç‚¹å›¾çœ‹çœ‹ä»·æ ¼/æˆ¿å­åˆ†å¸ƒ
sns.scatterplot(data=df, x="longitude", y="latitude", size="median_house_value", hue="median_house_value", ax=ax[0][0])

# ç›´æ–¹å›¾ï¼Œæ­£æ€å¦ï¼Ÿ
for col in df.columns:
    if col == "longitude" or col == "latitude" or col == "ocean_proximity":
        continue
    sns.histplot(data=df[col], bins=60, kde=True, ax=ax[(i - 1) // 3][(i - 1) % 3])
    i = i + 1

# åˆ†ç±»å˜é‡
sns.countplot(data=df,x="ocean_proximity",ax=ax[2][2])
```

### 2.2.2 æ•°æ®ä¹‹é—´å…³ç³»

```python
# è·æµ·è¿œè¿‘ VS æˆ¿é¾„
sns.displot(data=df,x="housing_median_age",hue="ocean_proximity",kind="kde")

# housing_median_ageæè¿°æ€§ç»Ÿè®¡
df.groupby('ocean_proximity')['housing_median_age'].describe()


# è·æµ·è¿œè¿‘ VS ä»·æ ¼
sns.displot(data=df,x="housing_median_age",hue="ocean_proximity",kind="kde")

# median_house_valueæè¿°æ€§ç»Ÿè®¡
df.groupby('ocean_proximity')['median_house_value'].describe()


# è¿ç»­å‹ VS è¿ç»­å‹
sns.pairplot(data=df.select_dtypes(include='float64'), kind='reg', diag_kind='hist')
plt.savefig("1.png")


# è®¡ç®—å˜é‡ä¹‹é—´çš„ç›¸å…³ç³»æ•°,çš®å°”é€Šç›¸å…³ç³»æ•°å±•ç¤ºçº¿æ€§ç›¸å…³å…³ç³»
df_corr = df.select_dtypes(include='float64').corr()
df_corr

# ç»˜åˆ¶çƒ­åŠ›å›¾
sns.heatmap(df_corr, cmap="Blues")
```

## 2.3 æ•°æ®é¢„å¤„ç†

```python
# 1ï¼‰å¤„ç†ç¼ºå¤±å€¼
# å–å‡ºæœ‰ç¼ºå¤±å€¼çš„åˆ—
# reshapeæ˜¯ä¸ºäº†é€‚åº”sklearnè¦æ±‚
total_bedrooms = df.loc[:, "total_bedrooms"].values.reshape(-1, 1)  

# å¤åˆ¶ä¸€ä»½ä¸ç ´ååŸæ•°æ®
filled_df = df.copy()  

# ä¸­ä½æ•°å¡«è¡¥
filled_df.loc[:, "total_bedrooms"] = SimpleImputer(strategy="median").fit_transform(total_bedrooms)  

# çœ‹ä¸€ä¸‹æ•ˆæœ
filled_df.info()


# 2ï¼‰ç¼–ç 
# ç¼–ç 
code = OneHotEncoder().fit_transform(filled_df.loc[:, "ocean_proximity"].values.reshape(-1, 1))

# åˆå¹¶
coded_df = pd.concat([filled_df, pd.DataFrame(code.toarray())], axis=1)

# åˆ é™¤åŸåˆ—
coded_df.drop(["ocean_proximity"], axis=1, inplace=True)

# æ”¹ä¸‹è¡¨å¤´
coded_df.columns = list(coded_df.columns[:-5]) + ["ocean_0", "ocean_1", "ocean_2", "ocean_3", "ocean_4"]
# coded_df.columns = coded_df.columns.astype(str)

# çœ‹çœ‹æ•ˆæœ
coded_df.head(10)
```

## 2.4 åˆ’åˆ†æ•°æ®é›†

```python
feature = coded_df.iloc[:, :8].join(coded_df.iloc[:, -5:])
label = coded_df["median_house_value"]

Xtrain,Xtest,Ytrain,Ytest = train_test_split(feature,label,test_size=0.3)

Xtrain.head()
```

## 2.5 æ±‚è§£æ¨¡å‹

### 2.5.0 è¯„ä»·æŒ‡æ ‡R^2

```python
# è®¡ç®—R^2
def R2(y, y_pred):
    return 1 - (np.sum((y - y_pred) ** 2) / np.sum((y - np.mean(y)) ** 2))
```

### 2.5.1 æ•°æ®æ ‡å‡†åŒ–

```python
# æ•°æ®æ ‡å‡†åŒ–
def normalize(X):
    sigma = np.std(X, axis=0)
    mu = np.mean(X, axis=0)
    X = (X - mu) / sigma
    return np.array(X)

X = np.array(Xtrain).reshape(np.size(Xtrain, 0), -1)
y = np.array(Ytrain).T.reshape(-1, 1)

# æ ‡å‡†åŒ–ï¼ˆé—­å¼æ±‚è§£å…¶å®ä¸éœ€è¦ï¼Œä½†æ¢¯åº¦ä¸‹é™éœ€è¦ï¼Œä¸ºäº†å¯¹æ¯”ç»Ÿä¸€éƒ½é‡‡ç”¨å½’ä¸€åŒ–ï¼‰
X = normalize(X)
y = normalize(y)
```

### 2.5.2 é—­åˆå½¢å¼æ±‚è§£

```python
# 1ï¼‰çº¿æ€§å›å½’æ¨¡å‹çš„é—­åˆå½¢å¼å‚æ•°æ±‚è§£
# æ­£è§„æ–¹ç¨‹æ±‚è§£
def Normal_Equation(X, y):
    return np.linalg.inv(X.T @ X) @ X.T @ y

start_time = time.time()
theta_ne = Normal_Equation(X, y)

print(f"èŠ±è´¹æ—¶é—´ï¼š{time.time() - start_time}")v
print(f"R^2ï¼š{R2(y, X @ theta_ne)}")

# åˆ›å»º DataFrame
result_cf = pd.DataFrame({"ColumnName": list(Xtrain.columns), "Theta": theta_ne.flatten()})
result_cf
```

### 2.5.3 æ¢¯åº¦ä¸‹é™æ±‚è§£

```python
# 2ï¼‰çº¿æ€§å›å½’æ¢¯åº¦ä¸‹é™å‚æ•°æ±‚è§£
# æŸå¤±å‡½æ•°
def MSE_Loss(y, y_pred):
    return np.sum((y_pred - y) ** 2) / (2 * np.size(y))

# æ¢¯åº¦ä¸‹é™
def GD(X, y, lr=0.01, epochs=5000):
    m, n = X.shape

    # åˆå§‹åŒ–å‚æ•°ä¸ºæ ‡å‡†æ­£æ€åˆ†å¸ƒ
    theta = np.random.randn(n, 1)
    # è®°å½•æ¯ä»£æŸå¤±
    loss = np.zeros(epochs)

    for epoch in range(epochs):
        # è®¡ç®—æ¢¯åº¦
        gradient = (1 / m) * (X.T @ (X @ theta - y))
        # æ›´æ–°å‚æ•°
        theta -= lr * gradient
        # è®°å½•æŸå¤±
        loss[epoch] = MSE_Loss(y, X @ theta)

    return theta, loss

start_time = time.time()
[theta_gd, loss] = GD(X, y)

print(f"èŠ±è´¹æ—¶é—´ï¼š{time.time() - start_time}")
print(f"R^2ï¼š{R2(y, X @ theta_gd)}")

# åˆ›å»º DataFrame
result_gd = pd.DataFrame({"ColumnName": list(Xtrain.columns), "Theta": theta_gd.flatten()})
result_gd

# ç»˜åˆ¶æŸå¤±å‡½æ•°æ¢¯åº¦ä¸‹é™æ›²çº¿
sns.lineplot(x=np.arange(5000), y=loss.flatten(), label='Loss Curve')

plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.title('Gradient Descent Loss Curve')
```

# 3.å®éªŒç»“æœ

## 3.1 æ¢ç´¢æ•°æ®ç‰¹å¾

![111](pic/111.png)

## 3.2 æ±‚è§£ç»“æœå±•ç¤º

![image-20240423233034490](pic/image-20240423233034490.png)
